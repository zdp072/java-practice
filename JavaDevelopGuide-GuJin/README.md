# 编程规约
## 命名风格
1. 【强制】抽象类命名使用Abstract或Base开头;异常类命名使用Exception结尾;测试类 命名以它要测试的类的名称开始，以 Test 结尾。

2. 【强制】POJO类中布尔类型变量都不要加is前缀，否则部分框架解析会引起序列化错误。

3. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使 用单数形式，但是类名如果有复数含义，类名可以使用复数形式。

4. 【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。

5. 【参考】Service/DAO层方法命名规约
> 1) 获取单个对象的方法用get做前缀，如: getXxx()。
> 
> 2) 获取多个对象的方法用list做前缀，如: listXxx()。 
> 
> 3) 获取统计值的方法用count做前缀，如: countXxx()。
> 
> 4) 插入的方法用save/insert做前缀，如: saveXxx()。
> 
> 5) 删除的方法用remove/delete做前缀，如: deleteXxx()。
> 
> 6) 修改的方法用update做前缀，如: updateXxx()。

6. 【参考】领域模型命名规约
> 数据对象:xxxDO，xxx为数据表名。
>
> 数据传输对象:xxxDTO，xxx为业务领域相关的名称。
>
> 展示对象:xxxVO，xxx一般为网页名称。

## 常量定义
1. 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。 
> 正例:缓存相关常量放在类CacheConsts下;系统配置相关常量放在类 ConfigConsts下。


## 代码格式
1. 【强制】注释的双斜线与注释内容之间有且仅有一个空格。

2. 【推荐】单个方法的总行数不超过 80 行。
> 正例:代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰;共性逻辑抽取成为共性方法，便于复用和维护。

## OOP规约
1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析 成本，直接用类名来访问即可。

2. 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。

3. 【强制】所有整型包装类对象之间值的比较，全部使用equals方法比较。

4. 【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。（参考Case1.java）

5. 【强制】定义数据对象DO类时，属性类型要与数据库字段类型相匹配。

6. 【强制】为了防止精度损失，禁止使用构造方法BigDecimal(double)的方式把 double值转化为BigDecimal对象。（参考Case2.java）

7. 【强制】所有的POJO类属性必须使用包装数据类型。RPC方法的返回值和参数必须使用包装数据类型。所有的局部变量使用基本数据类型。

8. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。

9. 【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。（参考Case3.java）

10. 【推荐】慎用Object的clone方法来拷贝对象。
> 说明:对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。

## 集合处理
1. 【强制】只要覆写equals，就必须覆写hashCode。因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。

2. 【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用
Iterator方式，如果并发操作，需要对Iterator对象加锁。（参考Case5.java）

3. 【推荐】集合初始化时，指定集合初始值大小。说明:HashMap使用HashMap(int initialCapacity)初始化。

4. 【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。
> 说明: keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap 中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了 entry中，效率更高。


## 并发处理
1. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程.
> 说明: 线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问 题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

2. 【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 
> 说明:Executors 返回的线程池对象的弊端如下:FixedThreadPool和SingleThreadPool: Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。CachedThreadPool:Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

3. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。（参考Case6.java）

4. 【强制】必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收。（参考Case7.java）

5. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。
> 说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。

6. 【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。（参考Case8.java）

## 控制语句
1. 【强制】在高并发场景中，避免使用“等于”判断作为中断或退出的条件。
> 说明: 如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。
> > 反例: 判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。

2. 【推荐】表达异常的分支时，少用if-else方式，超过3层的if-else的逻辑判断代码可以使用策略模式、状态模式等来实现。（参考Case10.java）

3. 【推荐】避免采用取反逻辑运算符。
> 正例:使用if (x < 628)来表达 x 小于 628。
> 
> 反例:使用if (!(x >= 628))来表达 x 小于 628。

## 注释规约
1. 【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用// xxx 方式

## 其他
1. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。

# 异常日志
## 异常处理


## 日志规约


# 单元测试


# 安全规约


# 数据库
## 建表规约


## 索引规约


## SQL语句


## ORM映射


# 工程结构
## 应用分层


## 二方库依赖


## 服务器

# 设计规约
